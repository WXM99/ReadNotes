# Chp 7 Link

- Linking

  代码数据片段组合成单一可执行文件的过程, enable separate compilation

  执行时间

  - compile time
  - load time
  - run time

  连接类型

  - static link
  - dynamic link (in shared library when loading)

## 1. Compiler Driver

Compiler Driver contains

- Preprocessor [cpp]
- Compiler [cc1]
- Assembler [as]
- Linker [ld]

mian.c 
[cpp]=> main.i (ASCII intermediate file)
[cc1]=> main.s (ASCII assembly-language file)
[as]=> main.o (Binary relocatable object file)

func.c
[cpp]=> func.i
[cc1]=> func.s
[as]=> func.o

[ld main.o + func.o]=> prog

## 2. Static Linking

Static Linker Linux LD

- input: a group of **Binary relocatable object files** and cmd args

- output: fully linked, loadable and executable object file.

- massions:

  - symble resolution

    > - the symbles target file define and refered
    > - a symble represent a 
    >   - funtion
    >   - global variable
    >   - static variable
    > - to associate each symble reference with the definition

  - relocation

    > - code from compiler and assembler start in the address 0
    > - linker relocate thoes symbles with a certain memory position
    > - modify all references to thoes symbles to point at the position
    > - linker relocation's instraction is generated by assembler, called **relocation entries**

Object file:

- collections of blocks of byte
- blocks contains 
  - code
  - appication data
  - data structure that guide assembler load.
- Linker link these blocks by
  - relocate the position of blocks
  - modify positions in code data blocks
- Linker is independent to target machine, compilers and assemblers isn't.

Binary relocatable object file

- code sections
- data sections

## 3. Object File

- Relocatable object file: 

  Binary code and data. can be  associated with other relocatable object files to generate an executable object file.

  Generated by assembler.

- Executable file

  binary code and data, can be loaded into memory and execute

  Generated by linker.

- Shared object file

  a kind of special relocatable object file, can be loaded into memory and linked dynamically, at either load time or run time. 

  Generated by assembler.

- Object file format

  the format to organize object file

  First Unix: .out (the same as executable obj file)

  Windows: Protable Executable format (PE)

  MacOS-X: Mach-O

  Linux Unix: Executable and linkable Format (ELF)

## 4. Relocatable Object File

![image-20190402204913456](/Users/Miao/Library/Mobile Documents/com~apple~CloudDocs/GitHub/ReadNotes/ICS/Chp 7 Link.assets/image-20190402204913456.png)

- ELF header: 

  16 bytes: 描述生成文件的系统的字大小和字节顺序 (大小端)

  Rest: 包含帮助linker解释和分析obj file的信息 

  - the size of ELF header
  - type of the obj file
  - machine type
  - offet of the section named section header table
  - the size and number of entried in the section header table

- ELF section header table:

  描述不同section的位置和大小, 每一个section中都有一个固定大小的entry

- Sections between header and section header table 

  > - .text: machine code of the compiled program
  >
  > - .rodata: read-only data. like jump table in switch, strings in printf
  >
  > - .data: 初始化的全局变量; 初始化的静态C变量 (local C variables are in stack or regs)
  >
  > - .bss: 未初始化的全局变量, 未初始化的静态变量, 所有被初始化为0的全局, 静态变量
  >
  >   obj file中这个section不占据实际空间, merely a place holder.
  >
  >   区分初始化和未初始化的var为了节省空间. 
  >
  >   未初始化的变量不用占据然和实际的存储空间, 运行时内存中分配这些变量为0
  >
  > - .symtab: symbol table. 存放程序中的函数, 全局变量的**定义和引用**信息
  >
  >   每个relocatable obj file都有. 不包含局部变量的entries
  >
  > - .rel.text: .text section中的location list. linker结合这个obj file时需要修改这些置. 调用外部函数和引用全局变量的指令都需要修改. executable obj file 中不需要重定位信息, 除非显式指明linker保留.
  >
  > - .rel.data: 模块中引用或定义的全局变量的重定位信息
  >
  >   已初始化的全局变量如果初始值是一个全局变量的地址或者外部定义函数的地址, 则需要在link时被修改
  >
  > - .debug: 调试符号表, 具有局部变量和类型定义的entries和C的源文件. -g编译时带有
  >
  > - .line: 原始C源程序行号和.text中机器指令的映射. -g编译时具有
  >
  > - .strtab: 字符串表. 包括symtab和debug中的符号表和header中的section names. 本质上是一个以null结尾的string sequence

## 5. Symbol and Symbol Tables

- Every relocatable object file (module m) has a symbol table 包含m定义和引用的符号信息, 每个symbol分为:
  - Global symbols in: 由m定义并能被其他module引用. 如非静态函数和全局变量

  - Global symbols out: 其他模块定义并被m引用的全局符号 (外部符号 extern UNDEF)如其他模块中的非静态函数和全局变量

  - Local symbols: 只被m定义和引用的局部符号. 静态C函数和全局变量, 在m中任何位置可见, 但是不能被其他模块引用

  不同于局部变量, 然而static的过程变量会在data or bss中, 并在symbol table中创建唯一名字的local linker symbol

Symbol table是汇编器产生的, 使用的是.s中的符号. 表中每一个entry的format

```c
typedef struct {
  int name;        /* Offset in strtab */
  char type: 4,    /* Function or Object */
  		 binding: 4; /* Local or Global */
  char reserved;   /* Unused */
  short section;   /* Section header table index */
  long value;      /* Section offset or abs addr */
  long size;       /* Object size in byte*/
} Elf64_Symbol
```

- name是对应的名字在strtab的offset, 指向以null结尾的string

- value是符号的名字, 对于relocatable来说是距离section header的偏移, 对于executable来说是绝对地址

- size是目标大小

- symtab除了符号entries, 还可以包含section的entries和原始源文件路径名entries

- section表示这些符号被分配到的section在section header table的引索

  pseudosections (只在relocatable带有) 在section header table中没有对应条目, 所以symbol的section会被linker特殊化解析为:

  - ABS: 不该被relocate的符号
  - UNDEF: 未定义的符号 (引用的extern外部符号, 包括函数)
  - COMMON: 还未分配位置的未初始化的数据目标 (value有对齐要求, size有最小大小)
    - COMMON section: 未初始化的全局变量
    - .bss section: 未初始化的静态变量, 初始化为0的全局或静态变量

## 6. Symbol Resolution

- Linker 通过 associate each symbol reference with a certain symbol definition (in  the input relocatable object file's symbol table) 来做 symbol resolution.

- 定义和引用在同一模块里:

  由编译器检查定义唯一, 同时编译器还保证静态局部变量(具有local linker symbol)名字唯一

- Compiler处理全局符号

  不是当前模块定义的symbol(变量名 函数名)会假设在其他模块中进行过定义

  在symtab中生成一个entry (section = UNDEF), 交给linker处理

  Linker在所有模块中都找不到的话则报错

  ### 6.1 Duplicate Symbol Names

- 强弱符号 (GLOBAL 不考虑static)
  - 强符号: 函数和已初始化(包括初始化为0)的全局变量 (.text .data UNDEF .bss) 
  - 弱符号: 未初始化的全局变量 (COMMON)

- 强弱规则: 

  1. 不允许多个同名强符号
  2. 若强符号和若符号同名, 选择强符号
  3. 多个弱符号同名, 选择任意
  4. 同名弱符号可进行强制的类型转换, 带来内存位覆盖的现象
  5. 强符号归类.data or .bss, 弱符号归类到COMMON将决定权交给Linker

- 静态构造必须模块内唯一, 分配到.data or .bss (不存在弱符号定义不明问题)

  多文件静态重名没有影响, 相互独立

### 6.2 Linking with Static Libraries

- Linker的工作方式

  - 读取relocatable object file, 连接后形成executable object file
  - 复制静态库到目标文件并输出executable object file
    - 静态库: 相关目标文件打包成一个单独的文件, 作为linker的输入
    - 常见的静态库: ISO C99定义的IO库

- 公共库的备选提供方式

  - 编译器集成. 如Pascal

  - 发布独立的库relocatable object file

    linux> gcc main.c /usr/lib/libc.o

    缺点在于库文件的副本太多, 运行时代码太多, 库的编译太漫长

  - 每个标准函数创建独立的relocatable object file
    linux> gcc main.c /usr/lib/printf.o ...

    缺点在于编译调用过程繁琐耗时

  - 静态库解决不同方法的缺点

    库函数为独立的模块, 在进行整体的静态库文件封装. 编译过程时指定库文件的名字来链接库中定义的函数

    linux> gcc main.c /usr/lib/libc.a

    链接时只复制被引用的目标模块,  提高空间利用率

- 静态库文件格式

  - archive 存档文件

  - 是一组链接的relocatable object file集合

  - archive文件头部描述了其包含的成员目标文件的大小和位置

  - 通过AR工具为自定义的文件创建archive

    linux> ar rcs arc_name.a reobj1.o reobj2.o

    在文件中或头文件声明过函数后就可以利用自定义的archive编译链接文件了

    linux> gcc -c main.c

    linux> gcc -static -o prog main.o ./arc_name.a

  - 链接器行为: -static表示构建一个完全链接的executable 加载时不需要再次链接

    在archive没有被源文件引用的模块不会被连接, 不会进入executable

### 6.3  Static Libraries to Resolve Reference

- Linker链接静态库采用了解析外部引用的方式(resolve external references)

  - Symbol resolution阶段: Linker从左向右扫描命令行上的relocatable object file和archive
  - Linker维护一个relocatable的集合E, E集合将会被合并为executable
  - 维护一个未解析符号集合U
  - 维护一个之前输入文件中定义过的符号集合D
  - 初始态: E, U, D都是空集

- 解析过程:

  - 扫描cmd line输入文件f, 判断是object file还是archive

  - 若为object file, 则将f放入E, 根据f的symtab填补D, U

  - 若为archive, 则尝试将U中的符号和archive中的成员匹配

    - 扫描archive中的成员文件. 
    - 若成员文件m定义了U中一个符号引用, 则添加m到E中
    - 删减U(根据符号), 扩充D(根据m). 
    - 扫描直到U, D不发生变化. 
    - 此时未进入E的archive成员文件被丢弃.
    - 继续处理下一个输入文件 

  - Linker扫描完成后, 检查U

    - U为空集: 合并和relocateE中的object file, 输出executable
    - U非空: ld输出错误, 链接失败

  - 解析过程决定了输入文件的顺序会影响link结果

    - archive文件如果早于其已用过的文件出现, 则引用将始终处于U(undefined)

    - archive文件一般放在命令行的结尾

    - 多个archive的成员函数相互独立, 则结尾的archive顺序随意

    - 若不独立, 则需要编译启动时手动重排列

      排列遵循向后定义原则: 前者外部引用的符号必须在后者定义

    - 为了满足依赖需求, cmdline上可以输入重复的库

      相互依赖型: 库x里引用了库y定义的符号, 反之亦真. foo.c 引用了二者

      linux> gcc foo.c libx.a liby.a libx.a

      (重复输入的只会是archive, obj扫描一次即可完成所有符号解析)

      或者合并libx和liby

### 7. Relcation

