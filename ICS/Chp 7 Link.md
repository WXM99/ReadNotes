# Chp 7 Link

- Linking

  代码数据片段组合成单一可执行文件的过程, enable separate compilation

  执行时间

  - compile time
  - load time
  - run time

  连接类型

  - static link
  - dynamic link (in shared library when loading)

## 1. Compiler Driver

Compiler Driver contains

- Preprocessor [cpp]
- Compiler [cc1]
- Assembler [as]
- Linker [ld]

mian.c 
[cpp]=> main.i (ASCII intermediate file)
[cc1]=> main.s (ASCII assembly-language file)
[as]=> main.o (Binary relocatable object file)

func.c
[cpp]=> func.i
[cc1]=> func.s
[as]=> func.o

[ld main.o + func.o]=> prog

## 2. Static Linking

Static Linker Linux LD

- input: a group of **Binary relocatable object files** and cmd args

- output: fully linked, loadable and executable object file.

- massions:

  - symble resolution

    > - the symbles target file define and refered
    > - a symble represent a 
    >   - funtion
    >   - global variable
    >   - static variable
    > - to associate each symble reference with the definition

  - relocation

    > - code from compiler and assembler start in the address 0
    > - linker relocate thoes symbles with a certain memory position
    > - modify all references to thoes symbles to point at the position
    > - linker relocation's instraction is generated by assembler, called **relocation entries**

Object file:

- collections of blocks of byte
- blocks contains 
  - code
  - appication data
  - data structure that guide assembler load.
- Linker link these blocks by
  - relocate the position of blocks
  - modify positions in code data blocks
- Linker is independent to target machine, compilers and assemblers isn't.

Binary relocatable object file

- code sections
- data sections

## 3. Object File

- Relocatable object file: 

  Binary code and data. can be  associated with other relocatable object files to generate an executable object file.

  Generated by assembler.

- Executable file

  binary code and data, can be loaded into memory and execute

  Generated by linker.

- Shared object file

  a kind of special relocatable object file, can be loaded into memory and linked dynamically, at either load time or run time. 

  Generated by assembler.

- Object file format

  the format to organize object file

  First Unix: .out (the same as executable obj file)

  Windows: Protable Executable format (PE)

  MacOS-X: Mach-O

  Linux Unix: Executable and linkable Format (ELF)

## 4. Relocatable Object File

![image-20190402204913456](/Users/Miao/Library/Mobile Documents/com~apple~CloudDocs/GitHub/ReadNotes/ICS/Chp 7 Link.assets/image-20190402204913456.png)

- ELF header: 

  16 bytes: 描述生成文件的系统的字大小和字节顺序 (大小端)

  Rest: 包含帮助linker解释和分析obj file的信息 

  - the size of ELF header
  - type of the obj file
  - machine type
  - offet of the section named section header table
  - the size and number of entried in the section header table

- ELF section header table:

  描述不同section的位置和大小, 每一个section中都有一个固定大小的entry

- Sections between header and section header table 

  > - .text: machine code of the compiled program
  >
  > - .rodata: read-only data. like jump table in switch, strings in printf
  >
  > - .data: 初始化的全局变量; 初始化的静态C变量 (local C variables are in stack or regs)
  >
  > - .bss: 未初始化的全局变量, 未初始化的静态变量, 所有被初始化为0的全局, 静态变量
  >
  >   obj file中这个section不占据实际空间, merely a place holder.
  >
  >   区分初始化和未初始化的var为了节省空间. 
  >
  >   未初始化的变量不用占据然和实际的存储空间, 运行时内存中分配这些变量为0
  >
  > - .symtab: symbol table. 存放程序中的函数, 全局变量的**定义和引用**信息
  >
  >   每个relocatable obj file都有. 不包含局部变量的entries
  >
  > - .rel.text: .text section中的location list. linker结合这个obj file时需要修改这些置. 调用外部函数和引用全局变量的指令都需要修改. executable obj file 中不需要重定位信息, 除非显式指明linker保留.
  >
  > - .rel.data: 模块中引用或定义的全局变量的重定位信息
  >
  >   已初始化的全局变量如果初始值是一个全局变量的地址或者外部定义函数的地址, 则需要在link时被修改
  >
  > - .debug: 调试符号表, 具有局部变量和类型定义的entries和C的源文件. -g编译时带有
  >
  > - .line: 原始C源程序行号和.text中机器指令的映射. -g编译时具有
  >
  > - .strtab: 字符串表. 包括symtab和debug中的符号表和header中的section names. 本质上是一个以null结尾的string sequence

## 5. Symbol and Symbol Tables

- Every relocatable object file (module m) has a symbol table 包含m定义和引用的符号信息, 每个symbol分为:
  - Global symbols in: 由m定义并能被其他module引用. 如非静态函数和全局变量

  - Global symbols out: 其他模块定义并被m引用的全局符号 (外部符号 extern UNDEF)如其他模块中的非静态函数和全局变量

  - Local symbols: 只被m定义和引用的局部符号. 静态C函数和全局变量, 在m中任何位置可见, 但是不能被其他模块引用

  不同于局部变量, 然而static的过程变量会在data or bss中, 并在symbol table中创建唯一名字的local linker symbol

Symbol table是汇编器产生的, 使用的是.s中的符号. 表中每一个entry的format

```c
typedef struct {
  int name;        /* Offset in strtab */
  char type: 4,    /* Function or Object */
  		 binding: 4; /* Local or Global */
  char reserved;   /* Unused */
  short section;   /* Section header table index */
  long value;      /* Section offset or abs addr */
  long size;       /* Object size in byte*/
} Elf64_Symbol
```

- name是对应的名字在strtab的offset, 指向以null结尾的string

- value是符号的名字, 对于relocatable来说是距离section header的偏移, 对于executable来说是绝对地址

- size是目标大小

- symtab除了符号entries, 还可以包含section的entries和原始源文件路径名entries

- section表示这些符号被分配到的section在section header table的引索

  pseudosections (只在relocatable带有) 在section header table中没有对应条目, 所以symbol的section会被linker特殊化解析为:

  - ABS: 不该被relocate的符号
  - UNDEF: 未定义的符号 (引用的extern外部符号, 包括函数)
  - COMMON: 还未分配位置的未初始化的数据目标 (value有对齐要求, size有最小大小)
    - COMMON section: 未初始化的全局变量
    - .bss section: 未初始化的静态变量, 初始化为0的全局或静态变量

## 6. Symbol Resolution

- Linker 通过 associate each symbol reference with a certain symbol definition (in  the input relocatable object file's symbol table) 来做 symbol resolution.

- 定义和引用在同一模块里:

  由编译器检查定义唯一, 同时编译器还保证静态局部变量(具有local linker symbol)名字唯一

- Compiler处理全局符号

  不是当前模块定义的symbol(变量名 函数名)会假设在其他模块中进行过定义

  在symtab中生成一个entry (section = UNDEF), 交给linker处理

  Linker在所有模块中都找不到的话则报错

  ### 6.1 Duplicate Symbol Names

- 强弱符号 (GLOBAL 不考虑static)
  - 强符号: 函数和已初始化(包括初始化为0)的全局变量 (.text .data UNDEF .bss) 
  - 弱符号: 未初始化的全局变量 (COMMON)

- 强弱规则: 

  1. 不允许多个同名强符号
  2. 若强符号和若符号同名, 选择强符号
  3. 多个弱符号同名, 选择任意
  4. 同名弱符号可进行强制的类型转换, 带来内存位覆盖的现象
  5. 强符号归类.data or .bss, 弱符号归类到COMMON将决定权交给Linker

- 静态构造必须模块内唯一, 分配到.data or .bss (不存在弱符号定义不明问题)

  多文件静态重名没有影响, 相互独立

### 6.2 Linking with Static Libraries

- Linker的工作方式

  - 读取relocatable object file, 连接后形成executable object file
  - 复制静态库到目标文件并输出executable object file
    - 静态库: 相关目标文件打包成一个单独的文件, 作为linker的输入
    - 常见的静态库: ISO C99定义的IO库

- 公共库的备选提供方式

  - 编译器集成. 如Pascal

  - 发布独立的库relocatable object file

    linux> gcc main.c /usr/lib/libc.o

    缺点在于库文件的副本太多, 运行时代码太多, 库的编译太漫长

  - 每个标准函数创建独立的relocatable object file
    linux> gcc main.c /usr/lib/printf.o ...

    缺点在于编译调用过程繁琐耗时

  - 静态库解决不同方法的缺点

    库函数为独立的模块, 在进行整体的静态库文件封装. 编译过程时指定库文件的名字来链接库中定义的函数

    linux> gcc main.c /usr/lib/libc.a

    链接时只复制被引用的目标模块,  提高空间利用率

- 静态库文件格式

  - archive 存档文件

  - 是一组链接的relocatable object file集合

  - archive文件头部描述了其包含的成员目标文件的大小和位置

  - 通过AR工具为自定义的文件创建archive

    linux> ar rcs arc_name.a reobj1.o reobj2.o

    在文件中或头文件声明过函数后就可以利用自定义的archive编译链接文件了

    linux> gcc -c main.c

    linux> gcc -static -o prog main.o ./arc_name.a

  - 链接器行为: -static表示构建一个完全链接的executable 加载时不需要再次链接

    在archive没有被源文件引用的模块不会被连接, 不会进入executable

### 6.3  Static Libraries to Resolve Reference

- Linker链接静态库采用了解析外部引用的方式(resolve external references)

  - Symbol resolution阶段: Linker从左向右扫描命令行上的relocatable object file和archive
  - Linker维护一个relocatable的集合E, E集合将会被合并为executable
  - 维护一个未解析符号集合U
  - 维护一个之前输入文件中定义过的符号集合D
  - 初始态: E, U, D都是空集

- 解析过程:

  - 扫描cmd line输入文件f, 判断是object file还是archive

  - 若为object file, 则将f放入E, 根据f的symtab填补D, U

  - 若为archive, 则尝试将U中的符号和archive中的成员匹配

    - 扫描archive中的成员文件. 
    - 若成员文件m定义了U中一个符号引用, 则添加m到E中
    - 删减U(根据符号), 扩充D(根据m). 
    - 扫描直到U, D不发生变化. 
    - 此时未进入E的archive成员文件被丢弃.
    - 继续处理下一个输入文件 

  - Linker扫描完成后, 检查U

    - U为空集: 合并和relocateE中的object file, 输出executable
    - U非空: ld输出错误, 链接失败

  - 解析过程决定了输入文件的顺序会影响link结果

    - archive文件如果早于其已用过的文件出现, 则引用将始终处于U(undefined)

    - archive文件一般放在命令行的结尾

    - 多个archive的成员函数相互独立, 则结尾的archive顺序随意

    - 若不独立, 则需要编译启动时手动重排列

      排列遵循向后定义原则: 前者外部引用的符号必须在后者定义

    - 为了满足依赖需求, cmdline上可以输入重复的库

      相互依赖型: 库x里引用了库y定义的符号, 反之亦真. foo.c 引用了二者

      linux> gcc foo.c libx.a liby.a libx.a

      (重复输入的只会是archive, obj扫描一次即可完成所有符号解析)

      或者合并libx和liby

## 7. Relcation

符号解析完成后, 每个符号的引用和其定义 (symtab中的entry)关联了起来.

此时可由symtab中得知每个symbal(全局变量和函数)的size (bytes), 开始重定位. 合并输入模块, 并为每个符号分配运行时地址

- 重定位section和符号定义

  - linker将所有同类型的section merge成为一个aggregate section. 作为输出的executable的section; 

  - linker将运行地址分配给新的aggregate sections, input modules, defined symbols. 
  - 此时每条指令和全局变量都有唯一的运行内存地址

- 重定位section中的符号引用

  - 通过relocation entries这一data structure, Linker修改.text .data中对每个符号的引用, 指向正确的运行时地址
  - 获取正确的引用地址依赖于relocatable object file中的数据结构, 即relocation entry

### 7.1 Relocation Entries

- assembler生成的二进制代码没有数据和代码的在内存的位置信息, 所以也无法得知引用的外部函数和全局变量的位置信息

- assembler遇到位置未知的引用时, 会生成relocation entry

- relocation entry的作用是告知linker在进行合并object时应该如何修改引用

- relocation entries **for CODE**被放置在obj的,rel.text section

  relocation entries **for DATA**被放置在.rel.data中

- relocation entry 结构定义

  ```c
  typedef struct {
    long offset;    //offset of the reference to relocate
    long type: 32,  //relocation type
    		 symbol: 32;//symbol table index 
    long addend;//constant part of relocation expression 
  } Elf64_Rela;
  ```

  - offset: 需要被修改的引用所在的section offset
  - type: 修改引用的类型
  - symbol: 被修改的引用应该指向的符号在symbol table中的index
  - addend: 有符号, 某些类型的relocation使用add-end对被修改的引用值做偏移调整

- ELF定义的relocation type共有32种, 其中以下两种最基本

  - R_X86_64_PC32:

    > relocation 引用目标:  32位的PC relative address
    >
    > PC relative定义可见chp3 6.3
    >
    > 注意执行某条指令时, PC当前指令的指向下一条指令 (fetch goes first)

  - R_X86_64_32

    > relocation 引用目标:  32位的absolute address
    >
    > 绝对寻址时, Linker使得CPU直接使用指令中的值作为有效地址, 不进行修改

  两种类型支持x86-64的small code model. 即假设exe obj的.text 和.data一共小于2GB, 所以通过32位寻址. GCC默认使用small code model.

  编译更大的文件需要修改relocation type和代码模型, 通过以下参数修改

  ```bash
  -mcmodel=medium
  -mcmodel=large
  ```

  

### 7.2 Relocating Symbol Reference

> 重定位算法

````pseudocode
foreach section s{
  foreach relocation entry r{
    /* ptr to reference to be relocated */
    refptr = s + r.offset; 
    /* relocate a PC-relative reference */
    if(r.type == R_X86_64_PC32){
    	/* ref's run-time address */
      refaddr = ADDR(s) + r.offset /*real pos*/  
      *refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) /*holder pos*/
     }
      
    /* relocate an absolute reference */
    if(r.type == R_X86_64_32) {
       *refptr = (unsigned) (ADDR(r.symbol) + r.addend)
    } 
  }
}
````

- 在每个section和section相关的relocation entry上迭代执行
- section s 假定为一个字节数组
- relocation entry r 假定为Elf64_Rela结构
- Linker为各个节和symbol选定的地址通过ADDR()得到
- ```refptr```是指向需要被重定位的引用的指针
- Compiler生成的汇编代码首先会标记全局符号的引用
- Assembler会根据每个引用产生relocation entry
- objdump会把relocation entry所见到一行, 紧跟在对应引用后

> example

```c
/* orginal main.c */
int sum(int *a, int n);
int array[2] = {1, 2};
int main(){
  int val = sum(array, 2);
  return val;
}

/* orginal sum.c */
int sum(int *a, int n){
  int i, s = 0;
  for (i = 0; i < n; i++) {
    s += a[i]
  }
  return s;
}
```

#### 1. relocation PC-relative reference

调用sum函数

```assembly
...
e: e8 00 00 00 00   callq 13<main+0x13> # sum()
          f: R_X86_64_PC32      # relocation entry
...          
```

call指令开始于section偏移0xe的位置, callq的操作码0xe8占1字节, 所以relocation entry的地址为0xf, Compiler在此提供一个占位符

assembler会相应地在.rel.text存放对应的relocation entry r, 其结构如下

- r.offset = 0xf   // 引用相对位置
- r.symbol = 'sum' // 引用符号 实为symbol table index
- r.type = R_X86_64_PC32 // 重定位类型
- r.addend = -4 

> relocation entry r 要传递给linker的信息是
>
> 需要对位于相对开始**位置0xF**处的引用重定位

> Linker执行时, 可以通过**已完成的重定位section和符号定义**确定出ADDR(s)
>
> 对于本例: 
>
> ADDR(s) = ADDR(.text) = 0x4004d0               // sum引用出现的节位置 
>
> ADDR(r.symbol) = ADDR(sum) = 0x4004e8 // sum定义的位置
>
> 由重定位算法可知
>
> ``refaddr = ADDR(s) + r.offset ``
>
> ``= 0x4004d0+ 0xf = 0x4004df``
>
> 即为sum被引用的内存位置
>
> ``*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr )``
>
> ``=(unsigned) (0x4004e8 + (-4) - 0x4004df) = 0x5``
>
> 即为PC和sum之间的相对位置
>
> (或者理解为ADDR(r.symbol) - tmp_PC = ADDR(r.symbol) - (refaddr + leng(ref) )  )
>
> linker修改后可得
>
> ```assembly
> 4004de: e8 05 00 00 00  callq 4004e8  sum()
> ```



#### 2. Relocating Absolute Reference

读取全局变量array



























